---
title: 算法学习-递归
date: 2021-01-07 07:39:55
categories: 算法
tags: ['算法']
---

### 基于 leet_code 的递归算法的学习

#### 344.反转字符串
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符

示例 1：
```code
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```
示例 2：
```code
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

##### 代码：
```ts
function reverseString(s: string[]): void {
  const fn = (start: number, end: number, s: string[]) => {
    if (start > end) {
      return;
    }
    let tmp = s[start];
    s[start] = s[end];
    s[end] = tmp;
    fn(start + 1, end - 1, s);
  }

  fn(0, s.length - 1, s);
};
```
> 通过收尾替换的方式修改数组的值，左边的值 ++ ，右边的值--， 直到 left > right （索引）跳出递归

#### 509.斐波那契数
斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。

##### 代码
- **递归**
  ```ts
  let cache = new Map();
  function fib(N: number): number {
    if (N == 0) return 0
    if (N == 1) return 1
    if (cache.has(N)) {
      return cache.get(N)
    }
    let ret = fib(N - 1) + fib(N - 2)
    cache.set(N, ret);
    return ret;
  }
  ```
- **数组**
  ```ts
  function fibArr(n: number): number {
    let arr = [0, 1];
    for (let i = 2; i <= n; i++) {
      arr[i] = arr[i - 1] + arr[i - 2];
    }
    return arr[n];
  }
  ```

#### 206.反转链表
反转一个单链表。

示例:

```code
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```
```ts
function reverseList(head: ListNode | null): ListNode | null {
  if (head === null || head.next === null) {
    return head;
  }
  const node = reverseList(head.next);
  head.next.next = head;
  head.next = null;
  return node;
}
```

#### 104.二叉树的最大深度
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明**: 叶子节点是指没有子节点的节点。
**示例**：
给定二叉树 [3,9,20,null,null,15,7]，
```code
    3
   / \
  9  20
    /  \
   15   7
```
返回它的最大深度 3 。
```ts
function maxDepth(root: TreeNode | null): number {
  return root
    ? Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
    : 0
};
```

#### 50. Pow(x, n)
实现 `pow(x, n)` ，即计算 x 的 n 次幂函数。
**示例 1**:
```code
输入: 2.00000, 10
输出: 1024.00000
```
**示例 2**:
```code
输入: 2.10000, 3
输出: 9.26100
```
**示例 3**:
```code
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```
**说明**:
- -100.0 < x < 100.0
- n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。



#### 总结
- 递归算法的时间复杂度通常是递归调用的数量和计算的时间复杂度的乘积
- 递归算法的空间复杂度, 虑造成空间消耗的两个部分：
  - 递归相关空间 (不断执行递归，堆栈数据得不到释放，规模过大可能会导致堆栈溢出)
  - 非递归相关空间（与递归过程没有直接关系的内存空间，通常包括为全局变量分配的空间（通常在堆中））

> 记忆化技术优化递归性能

https://leetcode-cn.com/leetbook/read/recursion/xk5vw2/
